# pattern_matching

Сопоставление строки с образцом (рекурсия)
  "Даны две строки символов, длина которых заранее не известна. Первую строку мы рассматриваем как сопоставляемую, вторую - как образец. В образце символ «?» может сопоставляться с произвольным символом, а «*» - с произвольной подцепочкой символов (возможно пустой), остальные символы сопоставляются только сами с собой.
  На каждом шаге мы рассматриваем оставшиеся части строки и образца, которые изначально предстают в полной мере, как есть. Далее, при продвижении алгоритма, от строки и образца отбрасываются символы, стоящие вначале, и мы предполагаем, что для уже отброшенных символов сопоставление прошло успешно. Первое, что нужно сделать в начале каждого шага — это проверить, не кончился ли образец. Если он кончился, то результат зависит от того, кончилась ли при этом и строка тоже. Если кончилась, то мы фиксируем положительный результат сопоставления, иначе констатируем неудачу. Действительно с пустым образцом можно сопоставить только пустую строку. Если образец еще не кончился проверяем какой его символ рассматривается на данном шаге и сопоставляем с символов строки. В случае, когда в образце не «*», не «?» и не тождественный сверяемому символ, то алгоритм на этом завершается, констатирую неудачу. Соответственно, при совпадении первых символов или по нахождении в образце «?», мы отбрасываем их (то есть укорачиваем остатки обеих строк спереди) и возвращаемся к началу алгоритма.
  Самое интересное происходит, если на очередном шаге первым символом образца оказался «*». В этом случае нам нужно последовательно перебрать возможности сопоставления «*» с пустой подцепочкой строки, с одним символом строки, с двумя символами и так далее, пока не кончится сама строка. Делаем мы это следующим образом. Идентифицируем целочисленную переменную, которая будет обозначать текущий рассматриваемый вариант и присваиваем ей ноль, то есть начинаем рассмотрение с пустой цепочки. Теперь для каждой рассматриваемой альтернативы отбрасываем от образца «звездочку», а от строки столько символов, какое сейчас число в нашей переменной. Полученные остатки пытаемся сопоставить, используя для этого вызов той самой подпрограммы, которую мы сейчас пишем, то есть производим рекурсивный вызов «самих себя». Если результат вызова - «истина», то мы на этом завершаемся, то же вернув «истину». Если же результат «ложь», то мы проверяем можно ли еще увеличивать переменную, то есть не выйдем ли за пределы сопоставляемой строки. Если увеличиваться уже некуда, завершаем работу, вернув «ложь». В противном случае возвращаемся к началу цикла и рассматриваем следующее возможное значение длины цепочки, сопоставляемой со «звездочкой»." 

из книги Столярова Андрея Викторовича
